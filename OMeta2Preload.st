'From Moshi of 3 March 2007 [latest update: #908] on 21 May 2009 at 1:17:33 pm'!
Exception subclass: #OM2Fail
	instanceVariableNames: 'parserFailedAt'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2Preload'!
Object subclass: #OM2Failer
	instanceVariableNames: 'used'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2Preload'!
Object subclass: #OM2Stream
	instanceVariableNames: 'head tail memo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2Preload'!
OM2Stream subclass: #OM2StreamProxy
	instanceVariableNames: 'target'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2Preload'!
OM2Stream subclass: #OM2StreamDebugger
	instanceVariableNames: 'om2stream'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2Preload'!
OM2Stream subclass: #OM2LazyStream
	instanceVariableNames: 'stream pos'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2Preload'!
OM2Stream subclass: #OM2EndOfStream
	instanceVariableNames: 'stream pos'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2Preload'!
Compiler subclass: #OMeta2Compiler
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2Preload'!
Object subclass: #OMeta2Base
	instanceVariableNames: 'input om2streams haltingPoint'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2Preload'!
OMeta2Base subclass: #OMeta2
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2'!
OMeta2 subclass: #OMeta2RuleParser
	instanceVariableNames: 'temps'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2'!
OMeta2 subclass: #OMeta2RuleTranslator
	instanceVariableNames: 'grammarClass'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2'!
OMeta2 subclass: #OMeta2Optimizer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2'!
OMeta2 subclass: #OMeta2Flattener
	instanceVariableNames: 'ws'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2'!

!OM2Fail commentStamp: '<historical>' prior: 0!
I represent a match failure.  Try using #matchAll:with:ifFail: rather than handling me directly.!

!OM2Failer commentStamp: '<historical>' prior: 0!
I am used to capture left recursion failures.  Do not use me directly, I am an implementation detail.!

!OM2Stream commentStamp: '<historical>' prior: 0!
I, and my subclasses, are specialized pseudo-streams used by OMeta parsers.  We are implementation details... do not instantiate us.!

!OMeta2Compiler commentStamp: '<historical>' prior: 0!
I provide the interface that the Smalltalk environment expects.  In turn, I call out to various OMeta parsers that actually perform the compilation.

I use the indirection provided by OMeta2 class methods to allow for overriding of various functionality and make things a bit easier when trying out new extensions and optimization ideas for OMeta.! 

!OMeta2Base commentStamp: '<historical>' prior: 0!
I provide the core language/library runtime support for OMeta that cannot be rewritten as OMeta code.!

!OMeta2 commentStamp: '<historical>' prior: 0!
Smalltalk implementation!

!OMeta2RuleParser commentStamp: '<historical>' prior: 0!
Smalltalk implementation!

!OMeta2RuleTranslator commentStamp: '<historical>' prior: 0!
Smalltalk implementation!

!OMeta2Optimizer commentStamp: '<historical>' prior: 0!
Smalltalk implementation!

!OMeta2Flattener commentStamp: '<historical>' prior: 0!
Smalltalk implementation!

MethodNode subclass: #OMeta2MethodNode
        instanceVariableNames: ''
        classVariableNames: ''
        poolDictionaries: ''
        category: 'OMeta2Preload'!

!OMeta2MethodNode commentStamp: '<historical>' prior: 0!
I exist so that OMeta methods can be viewed in the code browsers.!

!OMeta2MethodNode methodsFor: 'debugger support' stamp: 'hmm 8/25/2012 14:28'!
schematicTempNamesString
        "The decompiler wants a list of temp names. However, this mechanism depends on a number of assumptions that do not hold with OMeta2 generated methods. Therefore we simply skip the temp names, letting the decompiler build generic ones.

This fixes an error when attempting to prettyPrint OMeta source code. (prettyPrint reveals the actual Smalltalk code generated by OMeta)"
        ^nil! !

!OMeta2 class methodsFor: 'methods' stamp: 'jmv 5/23/2019 10:44:30'!
methodNodeFor: sourceCode noPattern: aBoolean
	(OMeta2RuleParser isOMeta2Rule: sourceCode) ifTrue: [ ^ nil ].
	^ super methodNodeFor: sourceCode noPattern: aBoolean! !

!OM2Fail class methodsFor: 'exceptionInstantiator' stamp: 'pb 9/5/2017 13:01'!
parserFailedAt: positionInStream
	^ self new
		privateParserFailedAt: positionInStream;
		signal.! !

!OM2Fail methodsFor: 'exceptionDescription' stamp: 'aw 2/26/2009 11:03'!
defaultAction

	self error: 'match failed'! !

!OM2Fail methodsFor: 'accessing' stamp: 'pb 9/5/2017 13:01'!
parserFailedAt
	^ parserFailedAt.! !

!OM2Fail methodsFor: 'private' stamp: 'pb 9/5/2017 13:01'!
privateParserFailedAt: pos
	parserFailedAt := pos.! !

!OM2Failer methodsFor: 'initialization' stamp: 'aw 2/16/2009 14:23'!
initialize

	used := false! !

!OM2Failer methodsFor: 'initialization' stamp: 'aw 2/27/2009 13:44'!
used

	^ used! !

!OM2Failer methodsFor: 'evaluating' stamp: 'aw 2/27/2009 13:42'!
value

	used := true.
	OM2Fail signal! !

!OM2Stream methodsFor: 'private-ometa2preload' stamp: 'aw 2/26/2009 11:04'!
basicTail

	^ tail! !

!OM2Stream methodsFor: 'private-ometa2preload' stamp: 'pb 4/25/2020 01:00'!
ometaForgetEverything

	memo := IdentityDictionary new! !

!OM2Stream methodsFor: 'private-ometa2preload' stamp: 'aw 2/16/2009 11:35'!
head

	^ head! !

!OM2Stream methodsFor: 'private-ometa2preload' stamp: 'aw 2/16/2009 13:38'!
initHead: h tail: t

	head := h.
	tail := t! !

!OM2Stream methodsFor: 'initialization' stamp: 'aw 2/16/2009 11:34'!
initialize

	memo := IdentityDictionary new! !

!OM2Stream methodsFor: 'private-ometa2preload' stamp: 'aw 2/19/2009 23:13'!
inputSpecies

	^ Array! !

!OM2Stream methodsFor: 'private-ometa2preload' stamp: 'aw 2/16/2009 14:13'!
memo

	^ memo! !

!OM2Stream methodsFor: 'private-ometa2preload' stamp: 'pb 4/25/2020 01:00'!
ometaPositionInStream

	^ -1! !

!OM2Stream methodsFor: 'printing' stamp: 'aw 2/26/2009 11:05'!
printOn: aStream

	| inputIsString curr |
	inputIsString := (self inputSpecies inheritsFrom: String) and: [(self inputSpecies inheritsFrom: Symbol) not].
	curr := self.
	aStream
		nextPutAll: 'an ';
		nextPutAll: self class name;
		nextPut: $(.
	[curr notNil] whileTrue: [
		(curr isKindOf: OM2EndOfStream) ifTrue: [
			aStream nextPut: $).
			^ self
		].
		inputIsString
			ifTrue: [aStream nextPut: curr head]
			ifFalse: [
				curr head printOn: aStream.
				aStream space
			].
		curr := curr basicTail.
	].
	aStream nextPutAll: '...)'! !

!OM2Stream methodsFor: 'private-ometa2preload' stamp: 'aw 2/16/2009 11:35'!
tail

	^ tail! !

!OM2Stream methodsFor: 'private-ometa2preload' stamp: 'aw 2/26/2009 11:40'!
transitiveForgetEverything

	| curr |
	curr := self.
	[curr notNil] whileTrue: [
		curr ometaForgetEverything.
		curr := curr basicTail
	]! !

!OM2StreamProxy methodsFor: 'private-ometa2preload' stamp: 'aw 2/26/2009 11:05'!
basicTail

	^ target basicTail! !

!OM2StreamProxy methodsFor: 'private-ometa2preload' stamp: 'pb 2/21/2018 2:29'!
head

	^ head ifNil: [head := target head].
! !

!OM2StreamProxy methodsFor: 'private-ometa2preload' stamp: 'aw 2/19/2009 23:45'!
initTarget: anOM2Stream

	target := anOM2Stream! !

!OM2StreamProxy methodsFor: 'private-ometa2preload' stamp: 'aw 2/19/2009 23:13'!
inputSpecies

	^ target inputSpecies! !

!OM2StreamProxy methodsFor: 'private-ometa2preload' stamp: 'pb 4/25/2020 01:00'!
ometaPositionInStream

	^ target ometaPositionInStream! !

!OM2StreamProxy methodsFor: 'private-ometa2preload' stamp: 'pb 2/21/2018 2:29'!
tail

	^ tail ifNil: [tail := OM2StreamProxy for: target tail].
! !

!OM2StreamProxy methodsFor: 'private-ometa2preload' stamp: 'aw 2/16/2009 14:10'!
target

	^ target! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

OM2StreamProxy class
	instanceVariableNames: ''!

!OM2StreamProxy class methodsFor: 'private-ometa2preload' stamp: 'aw 2/19/2009 23:44'!
for: anOM2Stream

	^ self new initTarget: anOM2Stream! !


!OM2StreamDebugger methodsFor: 'private-ometa2preload' stamp: 'pb 4/25/2020 01:00'!
ometaForgetEverything

	om2stream ometaForgetEverything! !

!OM2StreamDebugger methodsFor: 'private-ometa2preload' stamp: 'aw 2/26/2009 13:40'!
head

	^ om2stream head! !

!OM2StreamDebugger methodsFor: 'private-ometa2preload' stamp: 'aw 2/26/2009 15:26'!
initOm2stream: anOM2Stream

	om2stream := anOM2Stream! !

!OM2StreamDebugger methodsFor: 'private-ometa2preload' stamp: 'aw 2/27/2009 13:27'!
memo

	^ om2stream memo! !

!OM2StreamDebugger methodsFor: 'printing' stamp: 'aw 2/26/2009 15:57'!
printOn: aStream

	aStream nextPutAll: 'an OM2StreamDebugger('.
	om2stream printOn: aStream.
	aStream nextPut: $)! !

!OM2StreamDebugger methodsFor: 'private-ometa2preload' stamp: 'aw 2/26/2009 13:40'!
tail

	^ om2stream tail! !

!OM2StreamDebugger methodsFor: 'private-ometa2preload' stamp: 'aw 2/27/2009 13:29'!
transitiveForgetEverything

	om2stream transitiveForgetEverything! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

OM2StreamDebugger class
	instanceVariableNames: ''!

!OM2StreamDebugger class methodsFor: 'private-ometa2preload' stamp: 'aw 2/26/2009 15:28'!
for: anOM2Stream

	^ self new initOm2stream: anOM2Stream! !

!OM2LazyStream methodsFor: 'private-ometa2preload' stamp: 'aw 2/20/2009 14:50'!
initHead: h stream: s pos: p

	head := h.
	stream := s.
	pos := p! !

!OM2LazyStream methodsFor: 'private-ometa2preload' stamp: 'aw 2/19/2009 23:15'!
inputSpecies

	^ stream originalContents species! !

!OM2LazyStream methodsFor: 'private-ometa2preload' stamp: 'pb 4/25/2020 01:00'!
ometaPositionInStream

	^ pos! !

!OM2LazyStream methodsFor: 'private-ometa2preload' stamp: 'aw 2/20/2009 14:42'!
tail

	tail ifNil: [tail := OM2LazyStream for: stream withPos: pos + 1].
	^ tail! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

OM2LazyStream class
	instanceVariableNames: ''!

!OM2LazyStream class methodsFor: 'private-ometa2preload' stamp: 'aw 2/20/2009 14:44'!
for: aReadStream withPos: pos

	^ aReadStream atEnd
		ifTrue: [OM2EndOfStream new initStream: aReadStream pos: pos]
		ifFalse: [self new initHead: aReadStream next stream: aReadStream pos: pos]! !

!OM2EndOfStream methodsFor: 'private-ometa2preload' stamp: 'aw 2/25/2009 11:29'!
head

	OM2Fail signal! !

!OM2EndOfStream methodsFor: 'private-ometa2preload' stamp: 'aw 2/20/2009 14:50'!
initStream: s pos: p

	stream := s.
	pos := p! !

!OM2EndOfStream methodsFor: 'private-ometa2preload' stamp: 'aw 2/19/2009 23:14'!
inputSpecies

	^ stream originalContents species! !

!OM2EndOfStream methodsFor: 'private-ometa2preload' stamp: 'pb 4/25/2020 01:00'!
ometaPositionInStream

	^ pos! !

!OM2EndOfStream methodsFor: 'private-ometa2preload' stamp: 'aw 2/25/2009 11:29'!
tail

	OM2Fail signal! !


!OMeta2Compiler methodsFor: 'private-ometa2preload' stamp: 'aw 2/18/2009 16:30'!
compile: origCode in: cls classified: aCategory notifying: notify ifFail: failBlock

	^ self compile: origCode in: cls notifying: notify ifFail: failBlock! !

!OMeta2Compiler methodsFor: 'private-ometa2preload' stamp: 'pb 4/27/2020 22:00'!
compile: origCode in: cls notifying: notify ifFail: failBlock

	| origCodeStream parseTree structuredCode translatedCode compilerStage|
	origCodeStream := origCode asString readStream.
	self from: origCodeStream class: cls context: nil notifying: notify.
	[
		compilerStage := 'Parsing'.
		parseTree := cls ometa2RuleParserClass matchStream: origCodeStream with: #rule withArgs: #() withPlaybackDebugging: false.
		compilerStage := 'Optimizing'.
		parseTree := cls ometa2OptimizerClass optimizeOMetaAst: parseTree.
		compilerStage := 'Translating'.
		structuredCode := cls ometa2RuleTranslatorClass match: parseTree with: #translate withArgs: {cls}.
		compilerStage := 'Flattening'.
		translatedCode := cls ometa2FlattenerClass match: structuredCode with: #flatten
	] on: OM2Fail do: [
		self notify: '<-- parse error around here -->' at: origCodeStream position.
		^ failBlock value
	].
	^ Compiler new
		compile: translatedCode readStream
		in: cls
		notifying: notify
		ifFail: failBlock! !

!OMeta2Compiler methodsFor: 'private-ometa2preload' stamp: 'aw 2/27/2009 13:10'!
parserClass

	^ self class! !

!OMeta2Compiler methodsFor: 'private-ometa2preload' stamp: 'pb 4/27/2020 22:00'!
parse: aStream class: aClass noPattern: noPattern context: ctxt notifying: req ifFail: aBlock

	^ [
		| parseTree structuredCode code node compilerStage|
		compilerStage := 'Parsing'.
		parseTree := aClass ometa2RuleParserClass matchAll: aStream contents with: #rule.
		compilerStage := 'Optimizing'.
		parseTree := aClass ometa2OptimizerClass optimizeOMetaAst: parseTree.
		compilerStage := 'Translating'.
		structuredCode := aClass ometa2RuleTranslatorClass match: parseTree with: #translate withArgs: {aClass}.
		compilerStage := 'Flattening'.
		code := aClass ometa2FlattenerClass match: structuredCode with: #flatten.
		node := Parser new parse: code readStream class: aClass noPattern: noPattern context: ctxt notifying: req ifFail: aBlock.
		OMeta2MethodNode adoptInstance: node.
		node
	] on: OM2Fail do: [aBlock value]! !

!OMeta2Compiler methodsFor: 'private-ometa2preload' stamp: 'hmm 5/24/2010 10:51'!
parser
        ^ self parserClass new! !

!OMeta2Base methodsFor: 'ometa grammar' stamp: 'aw 2/16/2009 15:13'!
anything

	| ans |
	ans := input head.
	input := input tail.
	^ ans! !

!OMeta2Base methodsFor: 'private' stamp: 'aw 2/16/2009 14:01'!
pvtOMetaApply
	| aRule |
	aRule := self apply: #anything.
	^ self apply: aRule! !

!OMeta2Base methodsFor: 'ometa grammar' stamp: 'pb 4/25/2020 01:00'!
apply: aRule
    "A memoRec is an association whose key is the answer, and whose value is the next input. Failers pretend to be memoRecs, but throw a fail in response to #value"
	| memo memoRec |
	input == haltingPoint ifTrue: [self halt].
	memo := input memo.
	memoRec := memo at: aRule ifAbsent: [nil].
	memoRec ifNil: [
		| origInput failer ans |
		origInput := input.
		failer := OM2Failer new.
		memo at: aRule put: failer.
		ans := self perform: aRule.
		memoRec := ans -> input.
		memo at: aRule put: memoRec.
		failer used ifTrue: [
			" left recursion detected "
			| sentinel keepGoing |
			sentinel := input.
			keepGoing := true.
			[keepGoing] whileTrue: [
				[
					input := origInput.
					ans := self perform: aRule.
					input == sentinel ifTrue: [OM2Fail parserFailedAt: input ometaPositionInStream].
					memoRec key: ans value: input.
				] on: OM2Fail do: [keepGoing := false]
			]
		]		
	].
	input := memoRec value.
	^ memoRec key! !

!OMeta2Base methodsFor: 'ometa grammar' stamp: 'pb 4/30/2020 20:00'!
apply: aRule withArgument: arg
	input := OM2Stream new
		initHead: arg
		tail: input.
	^ self perform: aRule.! !

!OMeta2Base methodsFor: 'ometa grammar' stamp: 'aw 2/16/2009 13:39'!
apply: aRule withArgs: args

	args reverseDo: [:a | input := OM2Stream new initHead: a tail: input].
	^ self perform: aRule! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 4/25/2020 01:00'!
pvtOMetaConsumedBy: aBlock

	| origInput i ws |
	origInput := input.
	aBlock value.
	ws := WriteStream on: origInput inputSpecies new.
	i := origInput.
	[i == input] whileFalse: [
		ws nextPut: i head.
		i := i tail
	].
	^ ws contents! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 4/25/2020 01:00'!
pvtOMetaForeignParser

	| aGrammar aRule g ans |
	aGrammar := self apply: #anything.
	aRule := self apply: #anything.
	g := aGrammar new initOMetaInputStream: (OM2StreamProxy for: input).
	ans := g apply: aRule.
	input := g ometaInputStream target.
	^ ans! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 5/2/2020 19:00'!
pvtOMetaGetExternalSmalltalkRecognizerClass
	"Use indirection to avoid hard-coding the parser name"
	^ OMeta2CuisSmalltalkRecognizer.! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 5/26/2015 14:53'!
pvtOMetaStreams
	^ om2streams ifNil: [om2streams := IdentityDictionary new].! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 4/25/2020 01:00'!
ometaForgetEverything

	input transitiveForgetEverything.
	self pvtOMetaStreams valuesDo: [:s | s transitiveForgetEverything]! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 5/24/2019 21:00'!
pvtOMetaIsForm: obj
	^ (obj isCollection and: [obj isSequenceable and: [obj isSymbol not]])! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 5/24/2019 21:00'!
pvtOMetaForm: aBlock

	| v origInput |
	v := self apply: #anything.
	self pvtOMetaPred: (self pvtOMetaIsForm: v).
	origInput := input.
	input := self pvtOMetaStreams at: v ifAbsentPut: [OM2LazyStream for: v readStream withPos: 1].
	aBlock value.
	self apply: #end.
	input := origInput.
	^ v! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 4/25/2020 01:00'!
pvtOMetaGenericMany: aBlock into: anOrderedCollection

	[
		| origInput |
		origInput := input.
		[anOrderedCollection addLast: aBlock value] on: OM2Fail do: [
			input := origInput.
			^ anOrderedCollection
		].
		true
	] whileTrue! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 4/25/2020 01:00'!
ometaHaltingPoint: anOM2Stream

	haltingPoint := anOM2Stream! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 4/25/2020 01:00'!
pvtOMetaIndexConsumedBy: aBlock
	"rangeAssoc"
	| from to |
	from := self ometaPositionInStream.
	aBlock value.
	to := self ometaPositionInStream.
	^ from -> to! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 4/25/2020 01:00'!
initOMetaInputStream: i

	input := i! !

!OMeta2Base methodsFor: 'initialization' stamp: 'aw 2/26/2009 11:16'!
initialize

	super initialize.
	om2streams := IdentityDictionary new! !

!OMeta2Base methodsFor: 'private' stamp: 'aw 2/16/2009 14:10'!
ometaInputStream

	^ input! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 4/25/2020 01:00'!
pvtOMetaLookahead: aBlock

	| origInput ans |
	origInput := input.
	ans := aBlock value.
	input := origInput.
	^ ans! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 4/25/2020 01:00'!
pvtOMetaMany1: aBlock
	"1 or more matches (i.e. +)"
	^ self pvtOMetaGenericMany: aBlock into: (OrderedCollection with: aBlock value)! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 4/25/2020 01:00'!
pvtOMetaMany: aBlock
	"0 or more matches (i.e. *)"
	^ self pvtOMetaGenericMany: aBlock into: OrderedCollection new! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 4/25/2020 01:00'!
pvtOMetaNot: aBlock

	| origInput |
	origInput := input.
	[aBlock value] on: OM2Fail do: [
		input := origInput.
		^ true
	].
	OM2Fail parserFailedAt: input ometaPositionInStream! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 5/24/2019 21:00'!
pvtOMetaOr: choices

	| origInput |
	origInput := input.
	choices do: [:choice |
		input := origInput.
		[^ choice value] on: OM2Fail do: []
	].
	OM2Fail parserFailedAt: input ometaPositionInStream! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 4/25/2020 01:00'!
pvtOMetaOpt: aBlock

	^ self pvtOMetaOr: {
		[aBlock value].
		[nil]
	}! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 4/25/2020 01:00'!
ometaPositionInStream
	"FIXME - called by examples.  Replace calls with @<>?"
	^ input ometaPositionInStream! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 4/25/2020 01:00'!
pvtOMetaPred: aBooleanValue

	" may want to have the compiler inline this automatically, for performance "
	aBooleanValue ifTrue: [^ true].
	OM2Fail parserFailedAt: input ometaPositionInStream! !

!OMeta2Base methodsFor: 'ometa grammar' stamp: 'aw 2/16/2009 16:16'!
seq

	| xs |
	xs := self apply: #anything.
	xs do: [:x |
		" may want to inline #apply:withArgs: below as an
		  optimization, since this rule gets used a lot "
		self apply: #exactly withArgument: x
	].
	^ xs
	! !

!OMeta2Base methodsFor: 'ometa grammar' stamp: 'aw 2/16/2009 15:03'!
super: superclass apply: aRule withArgs: args

	args reverseDo: [:a | input := OM2Stream new initHead: a tail: input].
	^ self perform: aRule withArguments: #() inSuperclass: superclass! !

!OMeta2Base methodsFor: 'ometa grammar' stamp: 'pb 4/30/2020 20:00'!
super: superclass apply: aRule withArgument: argument

	input := OM2Stream new initHead: argument tail: input.
	^ self perform: aRule withArguments: #() inSuperclass: superclass! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

OMeta2Base class
	instanceVariableNames: ''!

!OMeta2Base class methodsFor: 'matching' stamp: 'aw 2/26/2009 12:35'!
debugMatchAll: aSequenceableCollection with: aRule

	^ self debugMatchAll: aSequenceableCollection with: aRule withArgs: #()! !

!OMeta2Base class methodsFor: 'matching' stamp: 'aw 2/26/2009 12:53'!
debugMatchAll: aSequenceableCollection with: aRule withArgs: args

	^ self matchStream: aSequenceableCollection readStream with: aRule withArgs: args withPlaybackDebugging: true! !

!OMeta2Base class methodsFor: 'matching' stamp: 'aw 2/26/2009 12:52'!
debugMatch: anObject with: aRule

	^ self debugMatch: anObject with: aRule withArgs: #()! !

!OMeta2Base class methodsFor: 'matching' stamp: 'aw 2/26/2009 12:58'!
debugMatch: anObject with: aRule withArgs: args

	^ self debugMatchAll: {anObject} readStream with: aRule withArgs: args! !

!OMeta2Base class methodsFor: 'matching' stamp: 'aw 2/18/2009 15:39'!
matchAll: aSequenceableCollection with: aRule

	^ self matchAll: aSequenceableCollection with: aRule withArgs: #()! !

!OMeta2Base class methodsFor: 'matching' stamp: 'pb 3/14/2016 02:39'!
matchAll: aSequenceableCollection with: aRule withArgs: args
	"Recommended for use with unstructured data (i.e. strings and simple arrays)"
	^ self matchStream: aSequenceableCollection readStream with: aRule withArgs: args withPlaybackDebugging: false! !

!OMeta2Base class methodsFor: 'matching' stamp: 'pb 4/25/2020 01:00'!
matcherOn: aReadStream

	| input matcher |
	input := OM2LazyStream for: aReadStream withPos: 1.
	matcher := self new initOMetaInputStream: input.
	^ matcher! !

!OMeta2Base class methodsFor: 'private-ometa2preload' stamp: 'pb 4/25/2020 01:00'!
matchStream: aReadStream with: aRule withArgs: args withPlaybackDebugging: debugging

	| input matcher ans|
	input := OM2LazyStream for: aReadStream withPos: 1.
	matcher := self new initOMetaInputStream: input.
	[
		matcher apply: #empty withArgs: args.
		ans := matcher apply: aRule.
		matcher apply: #end.
	] on: OM2Fail do: [:e |
		| curr prev prevPrev |
		debugging ifFalse: [e pass].
		curr := input.
		prev := nil.
		prevPrev := nil.
		[curr notNil] whileTrue: [
			prevPrev := prev.
			prev := curr.
			curr := curr basicTail
		].
		curr := prevPrev ifNotNil: [prevPrev] ifNil: [prev].
		"FIXME - does this add any value?
		self inform: 'will halt each time matcher reaches ', curr printString.
		"
		matcher
			initOMetaInputStream: input;
			ometaForgetEverything.
		curr ifNil: [self error: 'you''ve found a bug -- please report it'].
		curr become: (OM2StreamDebugger for: curr copy).
		matcher ometaHaltingPoint: curr.
		matcher apply: #empty withArgs: args.
		ans := matcher apply: aRule.
		matcher apply: #end.
	].
	^ ans! !

!OMeta2Base class methodsFor: 'matching' stamp: 'pb 3/14/2016 02:39'!
match: anObject with: aRule
	"Recommended for use with structured data (i.e. arrays of arrays etc)"

	^ self match: anObject with: aRule withArgs: #()! !

!OMeta2Base class methodsFor: 'matching' stamp: 'aw 2/26/2009 12:55'!
match: anObject with: aRule withArgs: args

	^ self matchAll: {anObject} readStream with: aRule withArgs: args! !





























OMeta2 subclass: #OMeta2SqueakSmalltalkRecognizer
	instanceVariableNames: 'useArgTypeTable'
	classVariableNames: 'ArgTypeTable TypeTable'
	poolDictionaries: ''
	category: 'OMeta2'!
OMeta2SqueakSmalltalkRecognizer subclass: #OMeta2CuisSmalltalkRecognizer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2'!
OMeta2 subclass: #OMeta2NullOptimizer
	instanceVariableNames: 'didSomething'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2'!
OMeta2NullOptimizer subclass: #OMeta2AndOrOptimizer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2'!
OMeta2NullOptimizer subclass: #OMeta2FinalizeOptimizer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2'!

!OMeta2SqueakSmalltalkRecognizer commentStamp: '<historical>' prior: 0!
Smalltalk implementation!

!OMeta2CuisSmalltalkRecognizer commentStamp: '<historical>' prior: 0!
Smalltalk implementation!

!OMeta2NullOptimizer commentStamp: '<historical>' prior: 0!
Smalltalk implementation!

!OMeta2AndOrOptimizer commentStamp: '<historical>' prior: 0!
Smalltalk implementation!

!OMeta2FinalizeOptimizer commentStamp: '<historical>' prior: 0!
Smalltalk implementation!

!OMeta2 methodsFor: 'private-ometa2preload'!
char
	| t1 |
	t1 := self apply: #anything.
	self pvtOMetaPred: (t1 isKindOf: Character).
	^ t1! !

!OMeta2 methodsFor: 'private-ometa2preload'!
digit
	| t1 |
	t1 := self apply: #char.
	self pvtOMetaPred: t1 isDigit.
	^ t1! !

!OMeta2 methodsFor: 'private-ometa2preload'!
empty
	^ true! !

!OMeta2 methodsFor: 'private-ometa2preload'!
end
	^ self
		pvtOMetaNot: [self apply: #anything]! !

!OMeta2 methodsFor: 'private-ometa2preload'!
exactly
	| t1 t2 |
	t1 := self apply: #anything.
	t2 := self apply: #anything.
	self pvtOMetaPred: t1 = t2.
	^ t1! !

!OMeta2 methodsFor: 'private-ometa2preload'!
firstAndRest
	| t1 t2 |
	t1 := self apply: #anything.
	t2 := self apply: #anything.
	^ self
		pvtOMetaGenericMany: [self apply: t2]
		into: (OrderedCollection
				with: (self apply: t1))! !

!OMeta2 methodsFor: 'private-ometa2preload'!
fromTo
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| t x y |
	^ true ifTrue: [
		x := self apply: #anything.
		y := self apply: #anything.
		self
			apply: #seq
			withArgument: x.
		t := self pvtOMetaMany: [
			self pvtOMetaNot: [
				self
					apply: #seq
					withArgument: y ].
			self apply: #anything ].
		self
			apply: #seq
			withArgument: y.
		t ]! !

!OMeta2 methodsFor: 'private-ometa2preload'!
fromToEnd
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| from to |
	^ true ifTrue: [
		from := self apply: #anything.
		to := Character newLineCharacter asString.
		self
			apply: #fromToOrEnd
			withArgs:
				{from. to} ]! !

!OMeta2 methodsFor: 'private-ometa2preload'!
fromToOrEnd
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| t x y |
	^ true ifTrue: [
		x _ self apply: #anything.
		y _ self apply: #anything.
		self
			apply: #seq
			withArgument: x.
		t _ self pvtOMetaMany: [
			self pvtOMetaNot: [
				self
					apply: #seq
					withArgument: y ].
			self apply: #anything ].
		self pvtOMetaOr:
			{
				[
				self
					apply: #seq
					withArgument: y ]. 
				[ self apply: #end ]
			}.
		t ]! !

!OMeta2 methodsFor: 'private-ometa2preload'!
letter
	| t1 |
	t1 := self apply: #char.
	self pvtOMetaPred: t1 isLetter.
	^ t1! !

!OMeta2 methodsFor: 'private-ometa2preload'!
letterOrDigit
	| t1 |
	t1 := self apply: #char.
	self pvtOMetaPred: t1 isAlphaNumeric.
	^ t1! !

!OMeta2 methodsFor: 'private-ometa2preload'!
listOf
	| t1 t2 t3 |
	t1 := self apply: #anything.
	t2 := self apply: #anything.
	^ self pvtOMetaOr: {[t3 := self apply: t1.
		self
			pvtOMetaGenericMany: [self apply: #token withArgument: t2.
				self apply: t1]
			into: (OrderedCollection with: t3)]. [#()]}! !

!OMeta2 methodsFor: 'private-ometa2preload'!
lower
	| t1 |
	t1 := self apply: #char.
	self pvtOMetaPred: t1 isLowercase.
	^ t1! !

!OMeta2 methodsFor: 'private-ometa2preload'!
notLast
	| t1 t2 |
	t1 := self apply: #anything.
	t2 := self apply: t1.
	self
		pvtOMetaLookahead: [self apply: t1].
	^ t2! !

!OMeta2 methodsFor: 'private-ometa2preload'!
number
	| t1 |
	t1 := self apply: #anything.
	self pvtOMetaPred: t1 isNumber.
	^ t1! !

!OMeta2 methodsFor: 'private-ometa2preload'!
range
	| t1 t2 t3 |
	t1 := self apply: #anything.
	t2 := self apply: #anything.
	t3 := self apply: #anything.
	self pvtOMetaPred: t1 <= t3 & (t3 <= t2).
	^ t3! !

!OMeta2 methodsFor: 'private-ometa2preload'!
space
	| t1 |
	t1 := self apply: #char.
	self pvtOMetaPred: t1 asciiValue <= 32.
	^ t1! !

!OMeta2 methodsFor: 'private-ometa2preload'!
spaces
	^ self
		pvtOMetaMany: [self apply: #space]! !

!OMeta2 methodsFor: 'private-ometa2preload'!
string
	| t1 |
	t1 := self apply: #anything.
	self pvtOMetaPred: t1 isString.
	^ t1! !

!OMeta2 methodsFor: 'private-ometa2preload'!
symbol
	| t1 |
	t1 := self apply: #anything.
	self pvtOMetaPred: t1 isSymbol.
	^ t1! !

!OMeta2 methodsFor: 'private-ometa2preload'!
token
	| t1 |
	t1 := self apply: #anything.
	self apply: #spaces.
	^ self apply: #seq withArgument: t1! !

!OMeta2 methodsFor: 'private-ometa2preload'!
upper
	| t1 |
	t1 := self apply: #char.
	self pvtOMetaPred: t1 isUppercase.
	^ t1! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
application
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| as grm rule |
	^ self pvtOMetaOr:
		{
			[
			self
				apply: #token
				withArgument: '^'.
			rule _ self apply: #name.
			as _ self apply: #args.
			{#SuperApp. rule} , as ]. 
			[
			grm _ self apply: #name.
			self
				apply: #exactly
				withArgument: $..
			rule _ self apply: #nsName.
			as _ self apply: #args.
			{#App. #pvtOMetaForeignParser. grm. ('#' , rule) asSymbol} , as ]. 
			[
			rule _ self apply: #name.
			as _ self apply: #args.
			{#App. rule} , as ]
		}! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
args
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| ans |
	^ self pvtOMetaOr:
		{
			[
			self
				apply: #exactly
				withArgument: $(.
			ans := self
				apply: #listOf
				withArgs:
					{#squeakArgExprOrWrappedInnerBlock. ','}.
			self
				apply: #token
				withArgument: ')'.
			ans ]. 
			[
			self
				apply: #exactly
				withArgument: $(.
			ans := self
				apply: #listOf
				withArgs:
					{#squeakExpression. '.'}.
			self
				apply: #token
				withArgument: ')'.
			true ifTrue: [
			    "FIXME - uncomment to show warnings while loading...
				Transcript show: 'legacy listOf syntax with args: ' , ans asString; finishEntry."
				ans ]]. 
			[
			self pvtOMetaNot: [
				self
					apply: #exactly
					withArgument: $( ].
			#() ]
		}.! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
characterLiteral
	| t1 |
	self apply: #spaces.
	self apply: #exactly withArgument: $$.
	t1 := self apply: #char.
	^ {#App. #exactly. t1 storeString}! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
characters
	| t1 |
	self apply: #token withArgument: '``'.
	t1 := self
				pvtOMetaMany: [self
						pvtOMetaNot: [self apply: #exactly withArgument: $'.
							self apply: #exactly withArgument: $'].
					self apply: #char].
	self apply: #exactly withArgument: $'.
	self apply: #exactly withArgument: $'.
	^ {#App. #seq. (String withAll: t1) storeString}! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
expr
	| t1 |
	t1 := self apply: #listOf withArgs: {#expr4. '|'}.
	^ (OrderedCollection with: #Or) addAll: t1;
		 yourself! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
expr1
	| t1 t2 |
	^ self pvtOMetaOr: {[t1 := self pvtOMetaOr: {[self apply: #keyword withArgument: 'true']. [self apply: #keyword withArgument: 'false']. [self apply: #keyword withArgument: 'nil']}.
		{#App. #exactly. t1}]. [self apply: #application]. [self apply: #semanticAction]. [self apply: #semanticPredicate]. [self apply: #characters]. [self apply: #tokenSugar]. [self apply: #stringLiteral]. [self apply: #symbolLiteral]. [self apply: #numberLiteral]. [self apply: #characterLiteral]. [self apply: #token withArgument: '{'.
		t2 := self apply: #expr.
		self apply: #token withArgument: '}'.
		{#Form. t2}]. [self apply: #token withArgument: '<'.
		t2 := self apply: #expr.
		self apply: #token withArgument: '>'.
		{#ConsBy. t2}]. [self apply: #token withArgument: '@<'.
		t2 := self apply: #expr.
		self apply: #token withArgument: '>'.
		{#IdxConsBy. t2}]. [self apply: #token withArgument: '('.
		t2 := self apply: #expr.
		self apply: #token withArgument: ')'.
		t2]}! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
expr2
	| t1 |
	^ self pvtOMetaOr: {[self apply: #token withArgument: '~'.
		t1 := self apply: #expr2.
		{#Not. t1}]. [self apply: #token withArgument: '&'.
		t1 := self apply: #expr2.
		{#Lookahead. t1}]. [self apply: #expr1]}! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
expr3
	| t1 t2 |
	^ self pvtOMetaOr: {[t1 := self apply: #expr2.
		t1 := self apply: #optIter withArgument: t1.
		self pvtOMetaOr: {[self apply: #exactly withArgument: $:.
			t2 := self apply: #nsName.
			temps add: t2.
			{#Set. t2. t1}]. [t1]}]. [self apply: #token withArgument: ':'.
		t2 := self apply: #nsName.
		temps add: t2.
		{#Set. t2. {#App. #anything}}]}! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
expr4
	| t1 |
	t1 := self
				pvtOMetaMany: [self apply: #expr3].
	^ (OrderedCollection with: #And) addAll: t1;
		 yourself! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
initialize
	super initialize.
	temps := IdentitySet new! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
keyword
	| t1 |
	t1 := self apply: #anything.
	self apply: #token withArgument: t1.
	self
		pvtOMetaNot: [self apply: #letterOrDigit].
	^ t1! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
name
	self apply: #spaces.
	^ self apply: #nsName! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
nameFirst
	^ self apply: #letter! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
nameRest
	^ self pvtOMetaOr: {[self apply: #nameFirst]. [self apply: #digit]}! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
nsName
	| t1 |
	^ self pvtOMetaOr: {[t1 := self apply: #firstAndRest withArgs: {#nameFirst. #nameRest}.
		(String withAll: t1) asSymbol]. [self apply: #exactly withArgument: $_.
		^ #anything]}! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
numberLiteral
	| t1 t2 |
	self apply: #spaces.
	t1 := self pvtOMetaOr: {[self apply: #exactly withArgument: $-.
				self apply: #spaces.
				-1]. [1]}.
	t2 := self
				pvtOMetaMany1: [self apply: #digit].
	^ {#App. #exactly. (t1 * (String withAll: t2) asNumber) storeString}! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
optIter
	| t1 |
	t1 := self apply: #anything.
	^ self pvtOMetaOr: {[self apply: #token withArgument: '*'.
		{#Many. t1}]. [self apply: #token withArgument: '+'.
		{#Many1. t1}]. [self apply: #token withArgument: '?'.
		self
			pvtOMetaNot: [self apply: #exactly withArgument: $[].
		{#Opt. t1}]. [t1]}! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
ometaRule
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| n x xs |
	^ true ifTrue: [
		n := self pvtOMetaLookahead: [
			self pvtOMetaMany: [
				self
					super: OMeta2
					apply: #space
					withArgs: #() ].
			self apply: #nsName ].
		x := self
			apply: #rulePart
			withArgument: n.
		xs := self pvtOMetaMany: [
			self
				apply: #token
				withArgument: ','.
			self
				apply: #rulePart
				withArgument: n ].
		self apply: #spaces.
		self apply: #end.
		{
			#Rule. 
			n. 
			temps asSortedCollection. 
			(OrderedCollection
				with: #Or
				with: x)
				addAll: xs;
				yourself
		} ]! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
squeakRule
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| squeakCode |
	^ true ifTrue: [
		self pvtOMetaNot: [
			self pvtOMetaMany: [
				self
					super: OMeta2
					apply: #space
					withArgs: #() ].
			self apply: #nsName.
			self apply: #expr4.
			self
				apply: #token
				withArgument: '=' ].
		squeakCode _ self pvtOMetaConsumedBy: [ self pvtOMetaMany: [ self apply: #char ]].
		{#Squeak. squeakCode} ]! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
rule
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	^ self pvtOMetaOr:
		{[ self apply: #squeakRule ]. [ self apply: #ometaRule ]}.! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
rulePart
	| t1 t2 t3 |
	t1 := self apply: #anything.
	self pvtOMetaPred: (self apply: #name)
			= t1.
	t2 := self apply: #expr4.
	^ self pvtOMetaOr: {[self apply: #token withArgument: '='.
		t3 := self apply: #expr.
		{#And. t2. t3}]. [t2]}! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
semanticAction
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| blk expr |
	^ true ifTrue: [
		self pvtOMetaOpt: [
			self
				apply: #token
				withArgument: '->' ].
		self
			apply: #token
			withArgument: '['.
		self pvtOMetaOr:
			{[ expr := self apply: #squeakExpression ]. [ blk := self apply: #squeakInnerBlock ]}.
		self
			apply: #exactly
			withArgument: $].
		expr
			ifNil: [
				Array
					with: #SemBlkAct
					with: blk ]
			ifNotNil: [
				Array
					with: #SemAct
					with: expr ]]! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
semanticPredicate
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| blk expr |
	^ true ifTrue: [
		self
			apply: #token
			withArgument: '?['.
		self pvtOMetaOr:
			{[ expr := self apply: #squeakExpression ]. [ blk := self apply: #squeakInnerBlock ]}.
		self
			apply: #exactly
			withArgument: $].
		expr
			ifNil: [
				Array
					with: #SemBlkPred
					with: blk ]
			ifNotNil: [
				Array
					with: #SemPred
					with: expr ]]! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
space
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	^ self pvtOMetaOr:
		{
			[
			self
				super: OMeta2
				apply: #space
				withArgs: #() ]. 
			[
			self
				apply: #fromTo
				withArgs:
					{'/*'. '*/'} ]. 
			[
			self
				apply: #fromToEnd
				withArgument: '//' ]
		}! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
squeakArgExprOrWrappedInnerBlock
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| ans recog |
	^ true ifTrue: [
		recog _ self pvtOMetaGetExternalSmalltalkRecognizerClass.
		ans _ self
			apply: #pvtOMetaForeignParser
			withArgs:
				{recog. #squeakArgExprOrWrappedInnerBlock}.
		self apply: #spaces.
		ans ]! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
squeakExpression
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| ans recog |
	^ true ifTrue: [
		recog := self pvtOMetaGetExternalSmalltalkRecognizerClass.
		ans := self
			apply: #pvtOMetaForeignParser
			withArgs:
				{recog. #squeakExpr}.
		self apply: #spaces.
		ans ]! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
squeakInnerBlock
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| ans recog |
	^ true ifTrue: [
		recog := self pvtOMetaGetExternalSmalltalkRecognizerClass.
		ans := self
			apply: #pvtOMetaForeignParser
			withArgs:
				{recog. #squeakInnerBlock}.
		self apply: #spaces.
		ans ]! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
stringLiteral
	| t1 |
	self apply: #token withArgument: ''''.
	t1 := self
				pvtOMetaMany: [self pvtOMetaOr: {[self apply: #exactly withArgument: $'.
						self apply: #exactly withArgument: $'.
						$']. [self
							pvtOMetaNot: [self apply: #exactly withArgument: $'].
						self apply: #char]}].
	self apply: #exactly withArgument: $'.
	^ {#App. #exactly. (String withAll: t1) storeString}! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
symbolLiteral
	| t1 |
	self apply: #token withArgument: '#'.
	t1 := self apply: #nsName.
	^ {#App. #exactly. t1 storeString}! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
tokenSugar
	| t1 |
	self apply: #token withArgument: '"'.
	t1 := self
				pvtOMetaMany: [self
						pvtOMetaNot: [self apply: #exactly withArgument: $"].
					self apply: #char].
	self apply: #exactly withArgument: $".
	^ {#App. #token. (String withAll: t1) storeString}! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

OMeta2RuleParser class
	instanceVariableNames: ''!

!OMeta2RuleParser class methodsFor: 'private-ometa2preload'!
isOMeta2Rule: t1 
	^ [(self matchAll: t1 with: #rule) first ~= #Squeak]
		on: OM2Fail
		do: [false]! !


!OMeta2Optimizer class methodsFor: 'private-ometa2preload'!
optimizeOMetaAst: ast
	^ self
		match:
			(self
				match: ast
				with: #optimizeRule)
		with: #finalOptimizeRule.! !


!OMeta2Optimizer methodsFor: 'private-ometa2preload'!
optimizeRule
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| ans |
	^ true ifTrue: [
		ans := self apply: #anything.
		self pvtOMetaMany: [
			ans := self
				apply: #pvtOMetaForeignParser
				withArgs:
					{OMeta2AndOrOptimizer. #optimize. ans} ].
		ans ]! !


!OMeta2Optimizer methodsFor: 'private-ometa2preload'!
finalOptimizeRule
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| ans |
	^ true ifTrue: [
		ans _ self apply: #anything.
		self pvtOMetaMany: [
			ans _ self
				apply: #pvtOMetaForeignParser
				withArgs:
					{OMeta2FinalizeOptimizer. #optimize. ans} ].
		ans ]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
arrayConstr
	^ self pvtOMetaOr: {[true
			ifTrue: [self apply: #token withArgument: '{'.
				self apply: #expr.
				self
					pvtOMetaMany: [true
							ifTrue: [self apply: #token withArgument: '.'.
								self apply: #expr]].
				self pvtOMetaOr: {[self apply: #token withArgument: '.']. [self apply: #empty]}.
				self apply: #token withArgument: '}']]. [true
			ifTrue: [self apply: #token withArgument: '{'.
				self apply: #token withArgument: '}']]}! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
arrayLit
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	^ true ifTrue: [
		self
			apply: #token
			withArgument: '#'.
		self
			apply: #token
			withArgument: '('.
		self pvtOMetaMany: [
			self pvtOMetaOr:
				{
					[ self apply: #literal ]. 
					[ self apply: #arrayLit ]. 
					[ self apply: #arraySubLit ]. 
					[
					self apply: #commentAndSpaces.
					self apply: #tsArraySymbol ]
				} ].
		self
			apply: #token
			withArgument: ')' ]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
arraySubLit
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	^ true ifTrue: [
		self
			apply: #token
			withArgument: '('.
		self pvtOMetaMany: [
			self pvtOMetaOr:
				{
					[ self apply: #literal ]. 
					[ self apply: #arrayLit ]. 
					[ self apply: #arraySubLit ]. 
					[
					self apply: #commentAndSpaces.
					self apply: #tsArraySymbol ]
				} ].
		self
			apply: #token
			withArgument: ')' ]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
binary
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	^ true ifTrue: [
		self apply: #commentAndSpaces.
		self apply: #tsBinary ]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
binaryExpr
	^ self pvtOMetaOr: {[true
			ifTrue: [self apply: #binaryExpr.
				self apply: #binaryMsg]]. [self apply: #unaryExpr]}! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
binaryMsg
	^ true
		ifTrue: [self apply: #binary.
			self apply: #unaryExpr]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
block
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	^ true ifTrue: [
		self
			apply: #token
			withArgument: '['.
		self pvtOMetaOr:
			{
				[
				self pvtOMetaMany1: [
					self
						apply: #token
						withArgument: ':'.
					self apply: #identifier ].
				self
					apply: #token
					withArgument: '|' ]. 
				[ self apply: #empty ]
			}.
		self pvtOMetaOr:
			{
				[
				self
					apply: #token
					withArgument: '|'.
				self pvtOMetaMany: [ self apply: #identifier ].
				self
					apply: #token
					withArgument: '|' ]. 
				[ self apply: #empty ]
			}.
		self apply: #commentAndSpaces.
		self pvtOMetaOr:
			{
				[
				self apply: #expr.
				self pvtOMetaMany: [
					self
						apply: #token
						withArgument: '.'.
					self apply: #expr ].
				self pvtOMetaOr:
					{
						[
						self
							apply: #token
							withArgument: '.'.
						self
							apply: #token
							withArgument: '^'.
						self apply: #expr ]. 
						[ self apply: #empty ]
					} ]. 
				[
				self
					apply: #token
					withArgument: '^'.
				self apply: #expr ]. 
				[ self apply: #empty ]
			}.
		self apply: #commentAndSpaces.
		self pvtOMetaOr:
			{
				[
				self
					apply: #token
					withArgument: '.' ]. 
				[ self apply: #empty ]
			}.
		self apply: #commentAndSpaces.
		self
			apply: #token
			withArgument: ']' ]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
cascade
	^ self pvtOMetaOr: {[self apply: #identifier]. [self apply: #binaryMsg]. [self apply: #keywordMsg]}! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
comment
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	^ true ifTrue: [
		self
			apply: #exactly
			withArgument: $".
		self pvtOMetaConsumedBy: [
			self pvtOMetaMany: [
				self pvtOMetaNot: [
					self
						apply: #exactly
						withArgument: $" ].
				self apply: #anything ]].
		self
			apply: #exactly
			withArgument: $".
		self pvtOMetaOpt: [
			self
				apply: #exactly
				withArgument: $. ]]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
commentAndSpaces
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	^ true ifTrue: [
		self pvtOMetaOr:
			{
				[
				self pvtOMetaMany1: [
					self apply: #spaces.
					self apply: #comment ]]. 
				[
				self apply: #spaces.
				self pvtOMetaOpt: [ self apply: #comment ]]
			}.
		self apply: #spaces ]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
expr
	^ self pvtOMetaOr: {[true
			ifTrue: [self apply: #identifier.
				self pvtOMetaOr: {[self apply: #token withArgument: ':=']. [self apply: #token withArgument: '_']}.
				self apply: #expr]]. [self apply: #msgExpr]}! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
identifier
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	^ true ifTrue: [
		self apply: #commentAndSpaces.
		self apply: #tsIdentifier.
		self pvtOMetaNot: [
			self
				apply: #exactly
				withArgument: $: ]]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
initialize
	super initialize.
	useArgTypeTable := false! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
keyword
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	^ true ifTrue: [
		self apply: #commentAndSpaces.
		self apply: #tsKeyword ]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
keywordExpr
	^ true
		ifTrue: [self apply: #binaryExpr.
			self apply: #keywordMsg]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
keywordMsg
	^ self pvtOMetaOr: {[true
			ifTrue: [self apply: #keywordMsg.
				self apply: #keywordMsgPart]]. [self apply: #keywordMsgPart]}! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
keywordMsgPart
	^ true
		ifTrue: [self apply: #keyword.
			self apply: #binaryExpr]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
literal
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	^ true ifTrue: [
		self apply: #commentAndSpaces.
		self pvtOMetaOr:
			{[ self apply: #tsNumber ]. [ self apply: #tsCharacter ]. [ self apply: #tsString ]. [ self apply: #tsSymbol ]} ]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
msgExpr
	^ true
		ifTrue: [self pvtOMetaOr: {[self apply: #keywordExpr]. [self apply: #binaryExpr]}.
			self
				pvtOMetaMany: [true
						ifTrue: [self apply: #token withArgument: ';'.
							self apply: #cascade]]]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
pvtGetTypeTable
	^ useArgTypeTable
		ifTrue: [ ArgTypeTable ]
		ifFalse: [ TypeTable ]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
squeakExpr
	^ self
		pvtOMetaConsumedBy: [self apply: #expr]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
squeakInnerBlock
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| innerBlock |
	^ true ifTrue: [
		innerBlock := self pvtOMetaConsumedBy: [
			self pvtOMetaOr:
				{
					[
					self pvtOMetaMany1: [
						self
							apply: #token
							withArgument: ':'.
						self apply: #identifier ].
					self
						apply: #token
						withArgument: '|' ]. 
					[ self apply: #empty ]
				}.
			self pvtOMetaOr:
				{
					[
					self
						apply: #token
						withArgument: '|'.
					self pvtOMetaMany: [ self apply: #identifier ].
					self
						apply: #token
						withArgument: '|' ]. 
					[ self apply: #empty ]
				}.
			self pvtOMetaOr:
				{
					[
					self apply: #expr.
					self pvtOMetaMany: [
						self
							apply: #token
							withArgument: '.'.
						self apply: #expr ].
					self pvtOMetaOr:
						{
							[
							self
								apply: #token
								withArgument: '.'.
							self
								apply: #token
								withArgument: '^'.
							self apply: #expr ]. 
							[ self apply: #empty ]
						} ]. 
					[
					self
						apply: #token
						withArgument: '^'.
					self apply: #expr ]. 
					[ self apply: #empty ]
				}.
			self pvtOMetaOr:
				{
					[
					self
						apply: #token
						withArgument: '.' ]. 
					[ self apply: #empty ]
				} ].
		innerBlock ]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
squeakArgExprOrWrappedInnerBlock
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| expr inner |
	^ self pvtOMetaOr:
		{
			[
			self
				apply: #token
				withArgument: '['.
			inner _ self apply: #squeakInnerBlock.
			self
				apply: #token
				withArgument: ']'.
			'(true ifTrue: [' , inner , '])' ]. 
			[
			useArgTypeTable _ true.
			expr _ self apply: #squeakExpr.
			expr ]
		}! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
symbol
	^ true
		ifTrue: [self apply: #token withArgument: '#'.
			self apply: #spaces.
			self pvtOMetaOr: {[self apply: #tsString]. [true
					ifTrue: [self apply: #tsKeyword.
						self pvtOMetaOr: {[self apply: #tsIdentifier]. [self apply: #empty]}]]}]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
tcBinaryChar
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| x |
	^ true ifTrue: [
		x := self apply: #char.
		self pvtOMetaPred: (self pvtGetTypeTable at: x asciiValue) == #xBinary ]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
tsArraySymbol
	^ self pvtOMetaOr: {[true
			ifTrue: [self
					pvtOMetaMany1: [self apply: #tsKeyword].
				self pvtOMetaOr: {[self apply: #tsIdentifier]. [self apply: #empty]}]]. [self apply: #tsIdentifier]}! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
tsBinary
	^ true
		ifTrue: [self pvtOMetaOr: {[self apply: #exactly withArgument: $|]. [self apply: #tcBinaryChar]}.
			self
				pvtOMetaMany: [self apply: #tcBinaryChar]]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
tsCharacter
	^ true
		ifTrue: [self apply: #exactly withArgument: $$.
			self apply: #char]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
tsIdentifier
	^ true
		ifTrue: [self apply: #letter.
			self
				pvtOMetaMany: [self pvtOMetaOr: {[self apply: #letter]. [self apply: #digit]}]]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
tsKeyword
	^ true
		ifTrue: [self apply: #tsIdentifier.
			self apply: #exactly withArgument: $:]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
tsNatural
	^ self
		pvtOMetaMany1: [self apply: #digit]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
tsNumber
	^ true
		ifTrue: [self pvtOMetaOr: {[self apply: #exactly withArgument: $+]. [self apply: #exactly withArgument: $-]. [self apply: #empty]}.
			self apply: #tsNatural]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
tsString
	^ true
		ifTrue: [self apply: #exactly withArgument: $'.
			self
				pvtOMetaMany: [self pvtOMetaOr: {[true
							ifTrue: [self apply: #exactly withArgument: $'.
								self apply: #exactly withArgument: $']]. [true
							ifTrue: [self
									pvtOMetaNot: [self apply: #exactly withArgument: $'].
								self apply: #char]]}].
			self apply: #exactly withArgument: $']! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
tsSymbol
	^ true
		ifTrue: [self apply: #exactly withArgument: $#.
			self apply: #spaces.
			self pvtOMetaOr: {[self apply: #tsString]. [self apply: #tsArraySymbol]}]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
unaryExpr
	^ true
		ifTrue: [self apply: #unit.
			self
				pvtOMetaMany: [self apply: #identifier]]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
unit
	^ self pvtOMetaOr: {[self apply: #literal]. [self apply: #identifier]. [self apply: #arrayLit]. [self apply: #arrayConstr]. [self apply: #block]. [true
			ifTrue: [self apply: #token withArgument: '('.
				self apply: #expr.
				self apply: #token withArgument: ')']]}! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

OMeta2SqueakSmalltalkRecognizer class
	instanceVariableNames: ''!

!OMeta2SqueakSmalltalkRecognizer class methodsFor: 'private-ometa2preload'!
initialize
    TypeTable := #(#xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xDelimiter #xDelimiter #xBinary #xDelimiter #xDelimiter #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #doIt #xBinary #xDelimiter #xBinary #xDoubleQuote #xLitQuote #xDollar #xBinary #xBinary #xSingleQuote #leftParenthesis #rightParenthesis #xBinary #xBinary #xBinary #xBinary #period #xBinary #xDigit #xDigit #xDigit #xDigit #xDigit #xDigit #xDigit #xDigit #xDigit #xDigit #xColon #semicolon #xBinary #xBinary #xBinary #xBinary #xBinary #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #leftBracket #xBinary #rightBracket #upArrow #leftArrow #xBinary #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #leftBrace #verticalBar #rightBrace #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xLetter #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xLetter #xBinary #xBinary #xBinary #xBinary #xLetter #xBinary #xBinary #xBinary #xBinary #xBinary #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xBinary #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xBinary #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xBinary ).
	ArgTypeTable := TypeTable copy.
	ArgTypeTable
		at: 44
		put: #xLetter! !


OMeta2SqueakSmalltalkRecognizer initialize!

!OMeta2CuisSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
backtickExpr
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	^ true ifTrue: [
		self
			apply: #exactly
			withArgument: $`.
		self pvtOMetaMany: [
			self pvtOMetaNot: [
				self
					apply: #exactly
					withArgument: $` ].
			self apply: #anything ].
		self
			apply: #exactly
			withArgument: $` ]! !

!OMeta2CuisSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
byteArrayLit
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	^ true ifTrue: [
		self
			apply: #token
			withArgument: '#'.
		self
			apply: #token
			withArgument: '['.
		self pvtOMetaMany: [
			self pvtOMetaOr:
				{
					[ self apply: #literal ]. 
					[
					self apply: #commentAndSpaces.
					self apply: #tsArraySymbol ]
				} ].
		self
			apply: #token
			withArgument: ']' ]! !

!OMeta2CuisSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
identifier
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	^ self pvtOMetaOr:
		{
			[
			self apply: #commentAndSpaces.
			self apply: #backtickExpr ]. 
			[
			self
				super: OMeta2SqueakSmalltalkRecognizer
				apply: #identifier
				withArgs:
					{} ]
		}! !

!OMeta2CuisSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
msgExpr
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	^ true ifTrue: [
		self pvtOMetaOr:
			{[ self apply: #keywordExpr ]. [ self apply: #binaryExpr ]}.
		self pvtOMetaMany: [
			self
				apply: #token
				withArgument: ';'.
			self apply: #cascade ].
		self pvtOMetaMany: [
			self
				apply: #token
				withArgument: '::'.
			self apply: #cascade ]]! !

!OMeta2CuisSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
tsSymbolIdentifier
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	^ true ifTrue: [
		self pvtOMetaConsumedBy: [
			self pvtOMetaOr:
				{
					[ self apply: #letter ]. 
					[
					self
						apply: #exactly
						withArgument: $_ ]
				}.
			self pvtOMetaMany: [
				self pvtOMetaOr:
					{
						[ self apply: #letter ]. 
						[ self apply: #digit ]. 
						[
						self
							apply: #exactly
							withArgument: $_ ]. 
						[
						self
							apply: #exactly
							withArgument: $: ]
					} ]]]! !

!OMeta2CuisSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
unit
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	^ self pvtOMetaOr:
		{
			[ self apply: #byteArrayLit ]. 
			[ self apply: #backtickExpr ]. 
			[
			self
				super: OMeta2SqueakSmalltalkRecognizer
				apply: #unit
				withArgs:
					{} ]
		}! !

!OMeta2NullOptimizer methodsFor: 'private-ometa2preload'!
and
	| t1 |
	^ true
		ifTrue: [t1 := self
						pvtOMetaMany: [self apply: #trans].
			t1 addFirst: #And;
				 yourself]! !

!OMeta2NullOptimizer methodsFor: 'private-ometa2preload'!
consby
	| t1 |
	^ true
		ifTrue: [t1 := self apply: #trans.
			{#ConsBy. t1}]! !

!OMeta2NullOptimizer methodsFor: 'private-ometa2preload'!
form
	| t1 |
	^ true
		ifTrue: [t1 := self apply: #trans.
			{#Form. t1}]! !

!OMeta2NullOptimizer methodsFor: 'private-ometa2preload'!
helped
	^ self pvtOMetaPred: didSomething! !

!OMeta2NullOptimizer methodsFor: 'private-ometa2preload'!
idxconsby
	| t1 |
	^ true
		ifTrue: [t1 := self apply: #trans.
			{#IdxConsBy. t1}]! !

!OMeta2NullOptimizer methodsFor: 'private-ometa2preload'!
initialize
	super initialize.
	didSomething := false! !

!OMeta2NullOptimizer methodsFor: 'private-ometa2preload'!
lookahead
	| t1 |
	^ true
		ifTrue: [t1 := self apply: #trans.
			{#Lookahead. t1}]! !

!OMeta2NullOptimizer methodsFor: 'private-ometa2preload'!
many
	| t1 |
	^ true
		ifTrue: [t1 := self apply: #trans.
			{#Many. t1}]! !

!OMeta2NullOptimizer methodsFor: 'private-ometa2preload'!
many1
	| t1 |
	^ true
		ifTrue: [t1 := self apply: #trans.
			{#Many1. t1}]! !

!OMeta2NullOptimizer methodsFor: 'private-ometa2preload'!
not
	| t1 |
	^ true
		ifTrue: [t1 := self apply: #trans.
			{#Not. t1}]! !

!OMeta2NullOptimizer methodsFor: 'private-ometa2preload'!
opt
	| t1 |
	^ true
		ifTrue: [t1 := self apply: #trans.
			{#Opt. t1}]! !

!OMeta2NullOptimizer methodsFor: 'private-ometa2preload'!
optimize
	| t1 |
	^ true
		ifTrue: [t1 := self apply: #trans.
			self apply: #helped.
			t1]! !

!OMeta2NullOptimizer methodsFor: 'private-ometa2preload'!
or
	| t1 |
	^ true
		ifTrue: [t1 := self
						pvtOMetaMany: [self apply: #trans].
			t1 addFirst: #Or;
				 yourself]! !

!OMeta2NullOptimizer methodsFor: 'private-ometa2preload'!
rule
	| t1 t2 t3 |
	^ true
		ifTrue: [t2 := self apply: #anything.
			t3 := self apply: #anything.
			t1 := self apply: #trans.
			{#Rule. t2. t3. t1}]! !

!OMeta2NullOptimizer methodsFor: 'private-ometa2preload'!
set
	| t1 t2 |
	^ true
		ifTrue: [t1 := self apply: #anything.
			t2 := self apply: #trans.
			{#Set. t1. t2}]! !

!OMeta2NullOptimizer methodsFor: 'private-ometa2preload'!
setHelped
	^ didSomething := true! !

!OMeta2NullOptimizer methodsFor: 'private-ometa2preload'!
trans
	| t1 t2 |
	^ self pvtOMetaOr: {[true
			ifTrue: [self
					pvtOMetaForm: [true
							ifTrue: [t1 := self apply: #anything.
								t1 := t1 asLowercase asSymbol.
								self
									pvtOMetaPred: (self class canUnderstand: t1).
								t2 := self apply: #pvtOMetaApply withArgument: t1]].
				t2]]. [self apply: #anything]}! !

!OMeta2NullOptimizer methodsFor: 'private-ometa2preload'!
trueiftrue
	| t1 |
	^ true
		ifTrue: [t1 := self apply: #trans.
			{#TrueIfTrue. t1}]! !

!OMeta2AndOrOptimizer methodsFor: 'private-ometa2preload'!
and
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| x xs |
	^ self pvtOMetaOr:
		{
			[
			x _ self apply: #trans.
			self apply: #end.
			self apply: #setHelped.
			x ]. 
			[
			xs _ self
				apply: #transInside
				withArgument: #And.
			xs
				addFirst: #And;
				yourself ]
		}! !

!OMeta2AndOrOptimizer methodsFor: 'private-ometa2preload'!
or
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| x xs |
	^ self pvtOMetaOr:
		{
			[
			x := self apply: #trans.
			self apply: #end.
			self apply: #setHelped.
			x ]. 
			[
			xs := self
				apply: #transInside
				withArgument: #Or.
			xs
				addFirst: #Or;
				yourself ]
		}! !

!OMeta2AndOrOptimizer methodsFor: 'private-ometa2preload'!
transInside
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| t x xs ys |
	^ true ifTrue: [
		t := self apply: #anything.
		self pvtOMetaOr:
			{
				[
				self pvtOMetaForm: [
					self
						apply: #exactly
						withArgument: t.
					xs := self
						apply: #transInside
						withArgument: t ].
				ys := self
					apply: #transInside
					withArgument: t.
				self apply: #setHelped.
				xs , ys ]. 
				[
				x := self apply: #trans.
				xs := self
					apply: #transInside
					withArgument: t.
				xs
					addFirst: x;
					yourself ]. 
				[
				self apply: #empty.
				OrderedCollection new ]
			} ]! !

!OMeta2FinalizeOptimizer methodsFor: 'private-ometa2preload'!
rule
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| body name temps |
	^ true ifTrue: [
		name := self apply: #anything.
		temps := self apply: #anything.
		body := self apply: #trans.
		OrderedCollection new
			add: #Rule;
			add: name;
			add: temps;
			add:
				((#(#Or #TrueIfTrue) includes: body first)
					ifTrue: [
						body ]
					ifFalse: [
						self setHelped.
						{#TrueIfTrue. body} ]);
			yourself ].! !

!OMeta2FinalizeOptimizer methodsFor: 'private-ometa2preload'!
set
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| name val |
	^ true ifTrue: [
		name := self apply: #anything.
		val := self apply: #trans.
		{
			#Set. 
			name. 
			val first = #And
				ifTrue: [
					self setHelped.
					{#TrueIfTrue. val} ]
				ifFalse: [ val ]
		} ].! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
semact
	| t1 |
	t1 := self apply: #string.
	^ {'('. t1. ')'}! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
semblkact
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| x |
	^ true ifTrue: [
		x := self apply: #string.
		{'true ifTrue:['. x. ']'} ]! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
and
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| xs |
	^ true ifTrue: [
		xs := self pvtOMetaMany: [ self apply: #trans ].
		{
			self
				delim: xs
				with: '. '
		} ]! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
app
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| args rule |
	^ true ifTrue: [
		self
			flag: #apply:;
			flag: #apply:withArgs:.
		rule := self apply: #symbol.
		self pvtOMetaOr:
			{
				[
				args := self pvtOMetaMany1: [ self apply: #anything ].
				args size = 1
					ifTrue: [
						{'(self apply: '. rule storeString. ' withArgument: '. args first. ')'} ]
					ifFalse: [
						{
							'(self apply: '. 
							rule storeString. 
							' withArgs: {'. 
							self
								delim: args
								with: '. '. 
							'})'
						} ]]. 
				[
				{'(self apply: '. rule storeString. ')'} ]
			} ]! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
consby
	| t1 |
	t1 := self apply: #trans.
	^ {'(self pvtOMetaConsumedBy: ['. t1. '])'}! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
delim: t1 with: t2 
	| t3 t4 |
	t3 := true.
	t4 := OrderedCollection new.
	t1
		do: [:t5 | 
			t3
				ifTrue: [t3 := false]
				ifFalse: [t4 add: t2].
			t4 add: t5].
	^ t4! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
form
	| t1 |
	t1 := self apply: #trans.
	^ {'(self pvtOMetaForm: ['. t1. '])'}! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
idxconsby
	| t1 |
	t1 := self apply: #trans.
	^ {'(self pvtOMetaIndexConsumedBy: ['. t1. '])'}! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
lookahead
	| t1 |
	t1 := self apply: #trans.
	^ {'(self pvtOMetaLookahead: ['. t1. '])'}! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
many
	| t1 |
	t1 := self apply: #trans.
	^ {'(self pvtOMetaMany: ['. t1. '])'}! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
many1
	| t1 |
	t1 := self apply: #trans.
	^ {'(self pvtOMetaMany1: ['. t1. '])'}! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
not
	| t1 |
	t1 := self apply: #trans.
	^ {'(self pvtOMetaNot: ['. t1. '])'}! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
opt
	| t1 |
	t1 := self apply: #trans.
	^ {'(self pvtOMetaOpt: ['. t1. '])'}! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
or
	| t1 t2 |
	t1 := self
				pvtOMetaMany: [t2 := self apply: #trans.
					{'['. t2. ']'}].
	^ {'(self pvtOMetaOr: {'. self delim: t1 with: '. '. '})'}! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
sempred
	| t1 |
	t1 := self apply: #string.
	^ {'(self pvtOMetaPred: ('. t1. '))'}! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
semblkpred
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| x |
	^ true ifTrue: [
		self flag: #pvtOMetaPred:.
		x _ self apply: #string.
		{'(self pvtOMetaPred: (true ifTrue:['. x. ']))'} ]! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
rule
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| body name temps |
	^ true ifTrue: [
		name := self apply: #symbol.
		temps := self apply: #anything.
		temps := temps select: [ :t |
			(grammarClass instVarNames includes: t) not ].
		body := self apply: #trans.
		{
			name. 
			self class constOMetaGeneratorString. 
			' |'. 
			self
				delim: temps asSortedCollection
				with: ' '. 
			' | ^ true ifTrue: ['. 
			body. 
			']'
		} ]! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
set
	| t1 t2 |
	t1 := self apply: #symbol.
	t2 := self apply: #trans.
	^ {'('. t1 asString. ' := '. t2. ')'}! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
squeak
	^ self apply: #string! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
superapp
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| args rule |
	^ true ifTrue: [
		self flag: #super:apply:withArgs:.
		rule := self apply: #symbol.
		args := self pvtOMetaMany: [ self apply: #anything ].
		args size = 1
			ifTrue: [
				{'(self super: '. grammarClass superclass name. ' apply: '. rule storeString. ' withArgument: '. args first. ')'} ]
			ifFalse: [
				{
					'(self super: '. 
					grammarClass superclass name. 
					' apply: '. 
					rule storeString. 
					' withArgs: {'. 
					self
						delim: args
						with: '. '. 
					'})'
				} ]]! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
trans
	| t1 t2 |
	self
		pvtOMetaForm: [t1 := self apply: #symbol.
			t2 := self apply: t1 asLowercase asSymbol].
	^ t2! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
translate
	grammarClass := self apply: #anything.
	^ self apply: #trans! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
trueiftrue
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| xs |
	^ true ifTrue: [
		xs := self pvtOMetaMany: [ self apply: #trans ].
		{'(true ifTrue: ['. xs. '])'} ]! !

!OMeta2RuleTranslator class methodsFor: 'constants' stamp: 'pb 5/23/2018 03:01:33'!
constOMetaGeneratorString
	"Not called yet but needs to exist for OMeta2.pck.st"
        ^ '"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"'.! !

!OMeta2Flattener methodsFor: 'private-ometa2preload'!
flatten
	| t1 |
	t1 := self apply: #anything.
	self apply: #iFlatten withArgument: t1.
	^ ws contents! !

!OMeta2Flattener methodsFor: 'private-ometa2preload'!
iFlatten
	| t1 |
	^ self pvtOMetaOr: {[t1 := self apply: #string.
		ws nextPutAll: t1]. [self
			pvtOMetaForm: [self
				pvtOMetaMany: [self apply: #iFlatten]]]}! !

!OMeta2Flattener methodsFor: 'private-ometa2preload'!
initialize
	super initialize.
	ws := (String new: 64) writeStream! !







!OMeta2Base class methodsFor: 'accessing' stamp: 'aw 2/20/2009 14:52'!
compilerClass
        ^ OMeta2Compiler! !

!OMeta2Base class methodsFor: 'private-ometa2preload' stamp: 'pb 6/08/2015 15:45'!
ometa2RuleParserClass
	^ OMeta2RuleParser! !

!OMeta2Base class methodsFor: 'private-ometa2preload' stamp: 'pb 6/08/2015 15:45'!
ometa2OptimizerClass
	^ OMeta2Optimizer! !

!OMeta2Base class methodsFor: 'private-ometa2preload' stamp: 'pb 6/08/2015 15:45'!
ometa2RuleTranslatorClass
	^ OMeta2RuleTranslator! !

!OMeta2Base class methodsFor: 'private-ometa2preload' stamp: 'pb 6/08/2015 15:45'!
ometa2FlattenerClass
	^ OMeta2Flattener! !


OM2Fail initialize!
OMeta2SqueakSmalltalkRecognizer initialize!

"-- END OF STAGE 1 BOOTSTRAP --"!
